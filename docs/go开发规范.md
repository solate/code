

# go 项目开发规范

## 目录

* [前言](#前言)
  * [为什么需要编码规范](#为什么需要编码规范)
  * [文档目的](#文档目的)
  * [规范实施建议](#规范实施建议)
* [编程规约](#编程规约)
  * [命名风格](#命名风格)
  * [代码格式](#代码格式)
  * [并发处理](#并发处理)
  * [控制语句](#控制语句)
  * [注释规约](#注释规约)
  * [其他](#其他)  
* 异常日志  
  * [异常处理](#异常处理)  
  * [日志规约](#日志规约)  
* [单元测试](#单元测试)  
* [安全规约](#安全规约)  
* [mysql数据库](#mysql数据库)
* [工程结构](#工程结构)
* [设计规约](#设计规约)
* [附1:版本历史](#附1:版本历史)
* [附2:专有名词解释](#附2:专有名词解释)
   

## 前言
    
### 为什么需要编码规范

1. 提高代码可读性
2. 减少人与人之间的沟通成本
3. 提高代码质量
4. 为团队建立脚手架
5. 节约智力的投入

### 文档目的

本文档主要反映中间件服务组go开发团队编码规范。主要目的为：

1. 以标准、规范的方式设计和编码。
2. 培养良好的编码风格和习惯
3. 形成约定，减少沟通成本
4. 提高产品质量，提高程序稳定性, 可读性, 一致性等

### 实施建议

该规范已提高软件开发质量和效率为目标，可以使用goland等开发工具为保障，逐步提高编码规范自动化。

可以使用goland自带`gofmt`、`go import`配置进行保存时代码格式化, 命令部分可以使用`golint`(有些强制命名规范觉得不是很合理).

使用`go vet .` 可以静态分析我们源码中存在的各种问题，比如多余的代码，提前return的逻辑，struct的tag是否符合标准 

使用`go run -race` 参数来进行竞争检测。

## 编程规约

* UpperCamelCase 首字母大写驼峰
* lowerCamelCase 首字母小写驼峰


### 命名风格

* 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
    ```
    反例: _name / $name / name_ / name$  
    ```
* 代码中命名不能使用拼音与英文混合, 不允许使用中文命名。即使是纯拼音命名也要避免
    ```
    正例: taobao / youku 等国际通用名称，可视为英文
    反例：getPingfenByName [评分]
    ```

* 尽量使用单个单词表达。
* 杜绝不规范缩写，避免文不知意, 随意缩写严重降低代码的可阅读性
* 所以尽量使用完整单词, 达到代码自解释的目的。



#### 项目名

由架构组制定命名规范，项目开发组长对项目命名，并由配置检查项目命令是否与其他项目冲突。

* 默认使用单个单词、缩写或多个单词字母小写命名, 多个单词使用中划线`-`进行连接


#### 包

* 使用单个单词表示, 如多个单词使用 `lowerCamelCase` 风格进行表示。
    ```
    正例: execute-manager  
    ``` 

#### 文件名

* 文件名使用全小写单词, 多个单词使用下划线 `_` 进行连接 

    ```
    正例: env_unix.go 
    ```

(官方有些是全小写中间不使用任何其他连接，但是实际使用有些单词很长，如果不进行分割会分不清楚, 
然后其他部分有使用下划线进行分割的，故选择下划线作为文件名)

#### 结构体

* 结构体名、属性名 使用`UpperCamelCase`风格
* tag 使用`_`下划线进行连接表示 (因为大部分json, mysql 都基本使用，可以直接拷贝)
* 每个个属性后需要添加注释
* 使用`New`开头的方法，用来实例化结构体

```
正例: 

type Admin struct {
	CompanyId   int                  `json:"company_id"`   // 公司id
	CompanyName string               `json:"company_name"` // 公司名称
	Status      int                  `json:"status"`       // 启用该用户 1 禁用, 2 启用
	exec        map[string]string    `json:"exec"`         // 操作
	
   
}

// 初始化Admin
func NewAdmin() *Admin {
    return &Admin{
        exec: make(map[string]string),
    }
}

// 新增
func (s *Admin) Create(param map[string]interface{}) (err error) {
	err = orm.Db.Create(&s).Error
	return
}

```

#### Tag 命名

* 单个单词，多个单词使用`_`下划线进行分割，字母小写。

#### 方法命名

##### 参数命名

* 使用单个单词表示, 如多个单词使用 `lowerCamelCase` 风格进行表示。


#### 变量命名

##### 全局变量

* 使用单个单词表示, 如多个单词使用 `UpperCamelCase` 风格进行表示。

```
正例: 

var (
    GlobalClient *client

)
```

全局变量中定义枚举：

* 枚举开始尽量从`1`开始，如默认值为0,则在反射等过程中无法知道是默认值还是传入值。
* 定义时需写清楚枚举的具体数值, 不使用`itoa`, 并加注释

```
正例: 

var (
    StatusBegin = 1   //开始
    StatusMiddle = 2  //中间
    StatusEnd =3      //结束
)
```
（这样再ide里可以直接看到值, 不用点过去看, 表达也更清楚）。

##### 局部变量

* 使用单个单词表示, 如多个单词使用 `lowerCamelCase` 风格进行表示。
* 尽量使用短式进行声明，在需要使用时才声明。

```
正例: 

flag := true

```


#### 常量命名

* 使用单个单词表示, 如多个单词使用 `UpperCamelCase` 风格进行表示。

```
正例: 

const (
    RegisterUrl = "xxxx"

)
```

(常规使用全大写下划线表示，但是有些单词全大写后就不认识了,不如小写好认,也不用下划线将变量弄的很长)


#### 测试命名

测试命名使用go测试命名规范

* 单元测试和测试文件同名，并在添加`_test`进行连接。
* 方法以`Test`开头连接测试的方法名




### 代码格式

使用 go fmt 进行格式化




### 并发处理


这里去查go 怎么去处理并发


* 高并发时，同步调用应该去考虑锁的性能损耗，能用无锁结构，就不要用锁。
* 对资源，数据库表，对象同时加锁时，需要保持一致性的加锁顺序，否则可能会造成死锁
* 


### 并发处理

### 控制语句

* 在switch块中，必须包含一个default语句，并且放在最后，即使空代码。

    防止没有匹配直接跳过swich语句，造成逻辑有误。

* 高并发场景，避免使用"等于"判断作为中断或退出的条件。

并发没有控制好, 容易产生等值判断被"击穿"的情况，使用大于或者小于的区间判断条件来代替。

```
判断剩余商品等于0时，不再卖出，但是并发处理后商品数量瞬间变为负数，则判断失效。
```
* 尽量少用if-else方式，改为

```
if condition {
    ....
    return 
}

// else 部分 
```

* [参考]需要进行参数校验

1. 调用平次低的方法
2. 执行时间开销很大的方法，此情形中，参数校验时间几乎可以忽略不计，但如果参数错误导致中间执行会退或者错误，那得不偿失
3. 需要极高稳定性和可用性的方法
4. 对外提供的开发接口，不管是RPC/API/HTTP接口
5. 敏感权限入口

* [参考]不需要进行参数校验

1. 极有可能被循环调用的方法，但在方法说明里必须注明外部参数检查要求
2. 底层调用频度比较高的方法。纯净水过滤最后一道，参数错误不太可能到底层才暴露问题，(models 层可以忽略)
3. 私有方法，自己调用能够确定调用方法的入参已经做过检查或者肯定不会有问题，可以不校验参数。



### 注释规约

鼓励养成写代码前先添加注释或者边写边添加注释的工作方式

1. 思路清晰
2. 规范代码
3. 增加代码可读性


必须要对返回值，参数，错误说明外，还必须指出该方法必须做什么事情，实现什么功能。


废弃的方法添加 deprecated 注释

* 注释全部使用 `//` 来进行注释，不使用`/* */`方式 
* 使用中文来进行注释
* 注释代码同步，修改代码需要同时修改注释
* 包注释: 创建`doc.go`文件，在`package`上添加对整个包的注释
* 方法注释：需要对方作用，参数，返回值进行说明
* struct注释：需对struct和属性都进行注释
* 代码质量不好可以运行，或还没有实现的功能使用//TODO 进行注释
* 所有枚举类型字段必须要有注释，说明没个数据项的用途
* 注释语句前加一个空格，如 `// 说明文字`


* [推荐] 与其"半吊子"英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。
* [推荐] 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等修改。

* [参考] 谨慎注释掉代码。在在上方详细说明,而不是简单的注释掉。如果无用，则删除。

代码注释有两种可能 1）后续会恢复此段代码逻辑。 2) 永久不用。 前者如果没有备注信息，难以知晓注释动机。 后者建议直接删除(代码仓库保存了历史代码)

* [参考] 对于注释的要求，第一、能够准确反应设计思想和代码逻辑；第二,能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形如天书，
注释是给自己看的，即使隔很长时间，也能清晰的理解当时的思路，注释也是给继任者看的，使其能够快速接替自己的工作。






### 其他

#### 导入

import导入引用包，将仓库全路径写入, 不使用相对路径，防止下载代码后代码没有引用问题。

可以配合vendor使用, 封装代码后放入公用项目中。

```
import (
	"bufio"
	"github.com/rcrowley/go-metrics"	
)
```


#### 格式化

使用goland自带`gofmt` 或者手动 `go fmt`代码后再上传到git仓库，方式大面积代码不一致冲突。

#### 减少编译程序体积

`go build` 编译程序时可以通过 `-ldflags` 来指定编译参数。`-s`的作用是去掉符号信息。 `-w`的作用是去掉调试信息。

```
GOOS=linux go build -ldflags "-w" -o test   bin/test.go
```

#### 通讯

* 使用RESTful 风格
* 返回值包含错误码，错误信息，数据三部分
* 数据直接通过json进行通讯

```
{"code": 400403, "message": "params error", "data": {"foo": "bar"}}
```

## 异常日志

### 日志

* 日志文件至少保存15天，因为有些异常具备周为频次发生的特点。
* 异常信息应该包含两类信息: 案发现场信息和异常堆栈信息。

* [推荐] 谨慎的记录日志。生产环境禁止输出debug日志。有选择地输出info日志；如果使用warn 来记录刚上线的业务行为信息，
一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。

        大量地无效日志，不利于系统性能提升，也不利于快速定位错误点，记录日志时请思考：这些日志真的有人看么？，看到这条日志你能做什么？能不能给问题排查带来好处？

* [推荐] 可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如飞必要，请不要在此场景打出error级别，避免频繁报警

    注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。

* [推荐] 尽量用英文来描述日志错误信息，如果日志中吃的错误信息用英文描述不清楚的话用中文描述即可，否则容易产生歧义
* [强制] 国际化的团队或海外部署的服务器由于字符集问题，强制使用全英文来注释和描述日志错误信息



## 单元测试

* 好的单元测试必须遵守AIR原则

    单元测试在线上运行时，感觉像空气(AIR) 一样并不存在，但在软件质量的保障上，却非常关键。好的单元测试宏观上来说，具有自动化，独立性、可重复执行的特点。

    * A: Automatic 自动化
    * I: Independent 独立性
    * R: Repeatable 可重复

* 单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义，输出结果需要人工检查的测试不是一个好的单元测试。
单元测试中不准使用fmt.Println来进行人肉验证，必须使用assert来验证

* 保持单元测试的独特性。为了保证单元测试稳定可靠并且便于维护，单元测试用例之间绝不能互相调用，也不能依赖执行的先后顺序



## 工程结构


### 基础结构

* build: 项目构建目录，目录中放置初始化脚本等
    * docker: docker构建需要的各种文件
        * Dockerfile
        * Shanghai
    * k8s: kubernetes yaml 文件等 k8s 集群需要配置
    * sql: 数据库文件: 建表和建库语句
    * sh: shell 脚本文件
* cmd: 多应用项目入口包，下面是多个项目的入口文件夹
    * demo: demo 项目
        * main.go: app项目入口,
        * app: app项目
            * config: 配置文件文件夹
            * component.go: 基础组件初始化
            * business.go: 业务组件初始化
* docs:文档笔记
    * images: 文档中图片放置位置,md中使用需要放置在外网可以访问的地址中           
* pkg: 各种微服务业务包
    * component: 初始化组件包，实例化项目中使用的单例结构
    * demo: demo 微服务
        * apis: demo 项目接口，
            * restful: http 接口包
            * pb: grpc 接口包
                * server: grpc server
                * client: grpc client
                * proto: proto协议包，如果有多种版本，则创建版本目录后放置协议文件。                                 
* test: 测试，本地写测试使用，不上传到正式代码仓库中
* utils: 封装方法，后期可以单独出去成为独立的模块
* vendor: 依赖包，go module 完全出来后可能有变动
* .gitignore: git 忽略文件
* LICENSE: 开源协议
* README.md: 项目介绍文档


### pkg下mvc格式微服务

* demo 
    * controllers: 业务控制层
    * middlewares: 中间件
    * models: 业务数据层
    * services: 业务处理层
    * sys: 和业务相关的帮助包


### 分布式项目包结构

* demo
    * types.go: model 结构包，单纯结构体
    * const.go: 放置常量
    * helper.go: 帮助方法放置
    * 其他组成构造业务包
 
model 如果需要使用gorm推荐使用同数据库名文件放置，并在内部实现增删改查而不使用types.



### 杂项 

(可删除，以前写的不知道有没有用)

1.	配置文件使用toml 进行配置
2.	每个文件应该有对应的test文件夹下建立测试
3.	笔记使用 名字.md 作为文档存出在Docs 文件夹下
4.	每次定义协议都要在Doc留存一个明确的协议文件进行说明（需求，实现，相关技术介绍，部署步骤，相关操作命令）
5.	正确分支和错误处理分支都要有相关日志进行记录， （日志格式需要进行讨论）
6.	使用orm 进行struct于数据库映射（gorm）
7.	统一的配置文件解析

### 建议

1. 不是用goto语句，业务中不会出现goto语句

## Q&A

go 协成部分 定义规范。


golint正确的安装方式




状态 0 全部 1 启用 2 禁用
